#!/usr/bin/env python
#=========================================================================
# sort-sim [options]
#=========================================================================
#
#  -h --help           Display this message
#
#  --impl              {cl,rtl-flat,rtl-struct}
#  --input <dataset>   {random,sorted-fwd,sorted-rev,zeros}
#  --trace             Display line tracing
#  --stats             Display statistics
#  --translate         Translate RTL model to Verilog
#  --dump-vcd          Dump VCD to sort-<impl>-<input>.vcd
#
# Author : Christopher Batten, Shunning Jiang
# Date   : Jan 23, 2020
#

# Hack to add project root to python path

import os
import sys

sim_dir = os.path.dirname( os.path.abspath( __file__ ) )
while sim_dir:
  if os.path.exists( sim_dir + os.path.sep + ".pymtl_sim_root" ):
    sys.path.insert(0,sim_dir)
    break
  sim_dir = os.path.dirname(sim_dir)

import argparse
import re

from random import randint

from pymtl3                            import *
from pymtl3.passes.backends.verilog    import (
  VerilogPlaceholderPass,
  TranslationImportPass,
  TranslationConfigs
)
from pymtl3.stdlib.test                import config_model
from tut3_pymtl.sort.SortUnitCL        import SortUnitCL
from tut3_pymtl.sort.SortUnitFlatRTL   import SortUnitFlatRTL
from tut3_pymtl.sort.SortUnitStructRTL import SortUnitStructRTL

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--impl", default="fl",
    choices=["cl","rtl-flat","rtl-struct"] )

  p.add_argument( "--input", default="random",
    choices=["random","sorted-fwd","sorted-rev","zeros"] )

  p.add_argument( "--trace",     action="store_true" )
  p.add_argument( "--stats",     action="store_true" )
  p.add_argument( "--translate", action="store_true" )
  p.add_argument( "--dump-vcd",  action="store_true" )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------

def main():
  opts = parse_cmdline()

  # Create input datasets

  ninputs = 100
  inputs  = []

  if opts.input == "random":
    for i in range(ninputs):
      inputs.append( [ randint(0,0xff) for i in range(4) ] )

  elif opts.input == "sorted-fwd":
    for i in range(ninputs):
      inputs.append( sorted([ randint(0,0xff) for i in range(4) ]) )

  elif opts.input == "sorted-rev":
    for i in range(ninputs):
      inputs.append( sorted([ randint(0,0xff) for i in range(4) ], reverse=True ) )

  elif opts.input == "zeros":
    for i in range(ninputs):
      inputs.append( [0]*4 )

  # Instantiate the model

  model_impl_dict = {
    'cl'         : SortUnitCL,
    'rtl-flat'   : SortUnitFlatRTL,
    'rtl-struct' : SortUnitStructRTL,
  }

  model = model_impl_dict[ opts.impl ]()

  # Check if translation is valid

  if opts.translate and not opts.impl.startswith("rtl"):
    print("\n ERROR: --translate only works with RTL models \n")
    exit(1)

  # Make sure the explicit module name is the same in both tut3 and tut4

  model_explicit_name_dict = {
    # It might be better to query the default parameters of the
    # construct method of `model`. But at this moment I'm not sure
    # if we have an API for that...
    'rtl-flat'   : 'SortUnitFlatRTL_8bit',
    'rtl-struct' : 'SortUnitStructRTL_8bit',
  }

  if opts.translate:
    if not hasattr( model, 'config_verilog_translate' ):
      model.config_verilog_translate = TranslationConfigs()
    model.config_verilog_translate.explicit_module_name = \
        model_explicit_name_dict[ opts.impl ]

  # Create VCD filename

  if opts.dump_vcd:
    vcd_file_name = f"sort-{opts.impl}-{opts.input}"
  else:
    vcd_file_name = ""

  # Configure the model

  config_model( model, vcd_file_name, opts.translate )

  # Apply necessary passes

  model.apply( VerilogPlaceholderPass() )

  model = TranslationImportPass()( model )

  # Create simulator

  model.apply( SimulationPass() )
  model.sim_reset(print_line_trace=opts.trace)

  # Tick simulator until evaluation is finished

  counter = 0
  while counter < ninputs:

    if model.out_val:
      counter += 1

    if inputs:
      model.in_val = b1(1)
      for i,v in enumerate( inputs.pop() ):
        model.in_[i] = b8(v)

    else:
      model.in_val = b1(0)
      for i in range(4):
        model.in_[i] = b8(0)

    model.eval_combinational()
    if opts.trace:
      model.print_line_trace()

    model.tick()

  # Report various statistics

  if opts.stats:
    print()
    print( "num_cycles          = {}".format( model.simulated_cycles ) )
    print( "num_cycles_per_sort = {:1.2f}".format( model.simulated_cycles/(1.0*ninputs) ) )

main()

